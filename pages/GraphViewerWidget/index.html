
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Graph viewer widget for Android</title>
	<meta name="author" content="JH">
	<link href='http://jheyman.github.io/blog/assets/themes/mytheme/css/style.css' rel="stylesheet" media="all">
	<link href="http://feeds.feedburner.com/" rel="alternate" title="Graph viewer widget for Android" type="application/atom+xml">
	<script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<a href="http://jheyman.github.io/blog/index.html"><img src="http://jheyman.github.io/blog/assets/images/common/hotglue_and_homemade_bits.png" height="100%" class="center" /></a>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					
<article class="unit-article layout-page">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Graph viewer widget for Android</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					
<p>After developing the <a href="http://jheyman.github.io/blog/pages/WirelessWaterMeter">wireless water meter</a>, I wanted to have an associated graphical front-end to visualize the water usage history. The obvious choice for my context was to develop an Android-based application so as to be able to integrate this graphical viewer in our <a href="http://jheyman.github.io/blog/pages/HomeHubTablet">home hub tablet</a>. As for other applications already hosted on this tablet (e.g. <a href="http://jheyman.github.io/blog/pages/PostitListWidget">PostitListWidget</a> or <a href="http://jheyman.github.io/blog/pages/ShoppingListWidget">ShoppingListWidget</a>), I decided to implement this viewer as a widget, not a regular android app. This makes things significantly more complex to develop, but this is balanced by the convenience to have all information available at all times on a unique screen (no need to explicitly launch/exit an application manually), which I think makes more sense for a screen on the wall.<br /><br /></p>

<ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
  <li><a href="#data-server" id="markdown-toc-data-server">Data server</a></li>
  <li><a href="#data-logger" id="markdown-toc-data-logger">Data logger</a></li>
  <li><a href="#android-widget" id="markdown-toc-android-widget"> Android widget</a>    <ul>
      <li><a href="#android-manifest" id="markdown-toc-android-manifest">Android manifest</a></li>
      <li><a href="#widget-layout" id="markdown-toc-widget-layout">Widget layout</a></li>
      <li><a href="#graphviewerwidgetprovider" id="markdown-toc-graphviewerwidgetprovider">GraphViewerWidgetProvider</a></li>
      <li><a href="#graphviewerwidgetservice" id="markdown-toc-graphviewerwidgetservice">GraphViewerWidgetService</a></li>
      <li><a href="#stackremoteviewsfactory" id="markdown-toc-stackremoteviewsfactory">StackRemoteViewsFactory</a></li>
      <li><a href="#graphviewerdataprovider" id="markdown-toc-graphviewerdataprovider">GraphViewerDataProvider</a></li>
      <li><a href="#settingsactivity" id="markdown-toc-settingsactivity">SettingsActivity</a></li>
    </ul>
  </li>
  <li><a href="#results" id="markdown-toc-results"> Results</a></li>
  <li><a href="#lessons-learned" id="markdown-toc-lessons-learned">Lessons learned</a></li>
</ul>

<hr />

<h3 id="overview">Overview</h3>

<p>The overall setup involves:</p>

<ul>
  <li>a <strong>data logger</strong> (the wireless water meter from <a href="http://jheyman.github.io/blog/pages/WirelessWaterMeter">this project</a>), modified to send its data to a remote data server.</li>
  <li>a <strong>data server</strong> to store this incoming data from the logger.</li>
  <li>the <strong>android widget</strong> to get a requested subset of data from the server, and display it on screen.<br /><br /></li>
</ul>

<p>I chose to host these three functions in three separate devices, that were already part of my home setup:</p>

<ul>
  <li>the data logger runs on a dedicated raspberry Pi, within radio range of the watermeter.</li>
  <li>the data server runs on my main raspberry Pi.</li>
  <li>the data viewer widget runs on the android wall tablet.<br /><br /></li>
</ul>

<p>Below is the overall implementation logic (don’t freak out):</p>

<p><img src="http://jheyman.github.io/blog/assets/images/GraphViewerWidget/implementation_overview.png" alt="implementation_overview" /></p>

<h3 id="data-server">Data server</h3>

<p>The widget queries data from a remote data server, which setup is documented <a href="http://jheyman.github.io/blog/pages/HomeDataLoggingServer">here</a>.</p>

<h3 id="data-logger">Data logger</h3>

<p>One source of incoming data is a slightly updated version of the watermeter logger (see <a href="http://jheyman.github.io/blog/pages/WirelessWaterMeter">here</a>), modified to perform an HTTP request on the data server to pass along the computed value (nb of liters consumed in the last 5 minutes). It boiled down to adding and using this python function:</p>

<pre><code>import urllib
import urllib2

def remoteLog(valueToLog):
	logger.info('Logging remotely...')
	data = 'homelogdata,graph=waterMeter value='+str(valueToLog)

	req = urllib2.Request(REMOTELOG_URL, data)
	req.add_header('Content-Length', '%d' % len(data))
	req.add_header('Content-Type', 'application/octet-stream')	
	
	try:
		response = urllib2.urlopen(req, timeout=5)
	except urllib2.HTTPError, e:
		logger.info('HTTPError: '+ str(e))
	except urllib2.URLError as e:
		logger.info('URLError: '+ str(e))
	else:
		result = response.read()
		logger.info('successfully logged data (' + data + ') remotely')
</code></pre>

<p>Another source of data is a python script performing a basic monitoring of my LAN devices ping status (nothing noteworthy, it just pings a predefined list of devices and logs the result in the data server, logging 1.0 for a successful ping and 0.0 for a failed ping (the source code is <a href="https://github.com/jheyman/HealthMonitor">here</a>)</p>

<h3 id="android-widget"> Android widget</h3>

<p>Preliminary notes:</p>

<ul>
  <li>since I intended to integrate the resulting widget in my <a href="http://jheyman.github.io/blog/pages/HomeHubTablet">home hub tablet</a>, which happens to run Android 4.0.3, I cannot rely on any feature not available in API level 15.</li>
  <li>the code was originally kickstarted using <a href="https://github.com/codeka/advbatterygraph">this guy’s code</a> that implements a nice Android battery status monitoring widget.</li>
  <li>the provided code is wrapped in an Android Studio project (using version 1.3.1 at the time of writing)</li>
</ul>

<h4 id="android-manifest">Android manifest</h4>
<p>Each android widget starts with a manifest file, like for regular android applications. The manifest includes:</p>

<ul>
  <li>the declaration of a <strong>Widget Provider</strong> class, acting as a broadcast receiver to handle the widget update notifications from Android. This declaration includes a reference to the file providing some parameters of the widget (here, <code>graph_viewer_widget_info.xml</code>):
    <ul>
      <li>the refresh period for the widget, in <code>updatePeriodMillis</code> parameter; Android enforces 30 minutes as a minimum.</li>
      <li>the min and max size of the widget on screen in case of user resize action.</li>
    </ul>
  </li>
  <li>the declaration of a <strong>Service</strong> class that will provide/adapt the RemoteViews for displaying the widget.</li>
  <li>the declaration of a <strong>Content Provider</strong> class for the widget, in charge of providing the source data to be displayed in the widget.</li>
  <li>the declaration of an <strong>Activity</strong> class to manage the settings page that a widget can optionally provide.</li>
</ul>

<h4 id="widget-layout">Widget layout</h4>

<p>The graphical layout is defined as follows:
<img src="http://jheyman.github.io/blog/assets/images/GraphViewerWidget/widget_layout.png" alt="widget layout" /></p>

<ul>
  <li>in the <strong>header</strong> section:
    <ul>
      <li>the ImageView will be dynamically rendered with specific text.</li>
      <li>the settings button is always visible.</li>
      <li>the reload button is visible by default, and then is hidden while a reload is in progres, being replaced by the progress bar (progress wheel, really) during that time.</li>
    </ul>
  </li>
  <li>the <strong>separator section</strong> for now just contains a 1px-height line, but could be made to be a more fancy info bar or whatever.</li>
  <li>the <strong>body section</strong> will contain the vertical list of graphs to be displayed
    <ul>
      <li>each list item is defined (in <code>widget_item.xml</code>) as a single ImageView.</li>
    </ul>
  </li>
  <li>the <strong>footer section</strong> contains a single ImageView that will be rendered dynamically to include timestamp markers (text and vertical lines)</li>
</ul>

<h4 id="graphviewerwidgetprovider">GraphViewerWidgetProvider</h4>
<p>The declared WidgetProvider-derived class manages the lifecycle of the widget:</p>

<ul>
  <li>it implements appropriate actions to be executed when the widget is <strong>installed/removed</strong> by the user, in <code>onEnabled/onDeleted</code> callbacks.</li>
  <li>it registers a <strong>graphical layout</strong> definition, and a RemoteAdapter service to provide its elements, to the Android widget management framework.</li>
  <li>it registers a <strong>data provider</strong> (through the context’s content resolver)</li>
  <li>it registers specific <code>PendingIntents</code> on the <strong>clickable buttons</strong> (i.e. it defines which event will be sent to the widget when user clicks this button)</li>
  <li>it renders the <strong>header</strong> and <strong>footer</strong> bitmaps
    <ul>
      <li>those are usually static/predefined, with no need for the widget provider to do anything specific</li>
      <li>but in my case, both the header and the footer have dynamic text &amp; graphics, so the corresponding ImageView object must be rendered.
        <ul>
          <li>the header contains rendered text, showing the time the data was last refreshed.</li>
          <li>the footer contains text rendering of the vertical time markers/timeline.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>it manages incoming <strong>events</strong>
    <ul>
      <li>update requests (from Android, following the requested update period)</li>
      <li>reload requests (triggered by the reload button on the widget)</li>
      <li>refresh requests (triggered internally after settings have been changed)</li>
    </ul>
  </li>
</ul>

<h4 id="graphviewerwidgetservice">GraphViewerWidgetService</h4>

<p>Pretty much an empty shell, it only overrides the <code>onGetViewFactory</code> to reference our <code>StackRemoteViewsFactory</code> class as being the provider/adapter of remote views to fill the widget’s body.</p>

<h4 id="stackremoteviewsfactory">StackRemoteViewsFactory</h4>

<p>This is where the bulk of the job is done:</p>

<ul>
  <li>whenever Android needs to render the widget, and specifically its body (our ListView), it calls <code>getCount</code> on this class to know how many items are in the list, then calls <code>getViewAt(position)</code> for all visible items in the list, to get the remote view to be rendered for each item. Specifically here, <code>getCount</code> returns the number of graphs to be displayed, and <code>getViewAt(position)</code>returns a bitmap (wrapped in a remote view) corresponding to the graph for this position in the list view. I currently implemented two types of graphs:
    <ul>
      <li><strong>bargraph</strong>, with automatic vertical scaling based on the maximum value in the dataset over the displayed period of time
        <ul>
          <li>with automatic display of cumulated value for each of the 16 sub-periods</li>
          <li>and an additional ability to specify a given time range of interest, where the cumulated value is computed and displayed (say, to monitor daily water consumption between 6am and 8am)</li>
        </ul>
      </li>
      <li><strong>binary graph</strong>, drawing a unique horizontal strip that is either green when value is 1.0, or red when value is 0.0<br /><br /></li>
    </ul>
  </li>
  <li>the data to be displayed on the graphs is refreshed whenever the <code>onDataSetChanged</code> notification is called (more on this later):
    <ul>
      <li>the class performs a query on the data provider, and receives a JSON-structured set of raw data (“raw” in the sense that values for different graphs are mixed up, since they are ordered in the order they were logged to the server).</li>
      <li>it parses the result, transforming the received JSON structure containing all unsorted data values into data values sorted by <code>dataId</code> key.<br /><br /></li>
    </ul>
  </li>
  <li>
    <p>each individual graph is drawn in memory by creating a Bitmap object/buffer, then computing data plot coordinates and rendering into the bitmap buffer using the Android <code>Canvas</code> API (providing very basic functions to draw lines, boxes, texts, …). This is bitmap is then registered to the appropriate RemoteView (<code>setImageViewBitmap</code> called in <code>getViewAt</code>)<br /><br /></p>
  </li>
  <li>A major difficulty I had was just to figure out the width and height of the graph to be rendered, since I am rendering bitmaps. For the life of me, with Android API 15 I dit not find any way to programmatically get the exact current height/width of the widget (or of any individual list item), so I went the lame way:
    <ul>
      <li>set the widget layout parameters so that the rendered images are stretched horizontally to the widget’s width.</li>
      <li>enforce a predefined height (and scale the graphs as appropriate).</li>
      <li>let the rendering width be a parameter modifiable in the settings screen, and adjust it manually so that the artifacts of the automatic stretching are minimized.</li>
    </ul>
  </li>
</ul>

<h4 id="graphviewerdataprovider">GraphViewerDataProvider</h4>

<p>This class encapsulates the remote/network access to get the actual data for the graphs from the data server. It performs an HTTP POST request, and receives a JSON formatted structure, which it then parses to fill a <code>Cursor</code> object, with one row per data item. The Cursor object is what gets returned to the <code>GraphViewerWidgetService</code>. The query specified inside the POST request contains the value of the time delay to cover, in hours:</p>

<pre><code>SELECT * FROM homelogdata WHERE time &gt; now - [delay]h
</code></pre>

<p>effectively returning all entries between [delay] hours ago and the current time.</p>

<h4 id="settingsactivity">SettingsActivity</h4>

<p>This class is derived from Android’s PreferenceActivity, and implements the (full screen) page that pops-up when one clicks on the settings icon of the widget. Upon creation, this activity loads the <code>graph_settings.xml</code> layout definition file, which structure is:</p>

<pre><code>&lt;PreferenceScreen &gt;
  &lt;PreferenceCategory&gt;
    &lt;EditTextIntegerPreference/&gt;
    &lt;ListPreference/&gt;
  &lt;/PreferenceCategory&gt;
&lt;/PreferenceScreen&gt;
</code></pre>

<p>This defines a single preference/settings screen, containing a single category/section, containing two settings:</p>

<ul>
  <li>an editable text for defining the width in pixels for graph rendering</li>
  <li>a multiple-choice list for defining the graph’s history depth.</li>
</ul>

<p>The history depth list values are defined in <code>array.xml</code>, it defines both the list of text to be displayed (the available durations), and the list of associated numerical values (hours)</p>

<pre><code>&lt;string-array name="history_length_display"&gt;
&lt;item&gt;8 hours&lt;/item&gt;
&lt;item&gt;12 hours&lt;/item&gt;
&lt;item&gt;1 day&lt;/item&gt;
&lt;item&gt;2 days&lt;/item&gt;
&lt;item&gt;3 days&lt;/item&gt;
&lt;item&gt;1 week&lt;/item&gt;
&lt;item&gt;1 month&lt;/item&gt;
&lt;/string-array&gt;

&lt;string-array name="history_length_values"&gt;
&lt;item&gt;8&lt;/item&gt;
&lt;item&gt;12&lt;/item&gt;
&lt;item&gt;24&lt;/item&gt;
&lt;item&gt;48&lt;/item&gt;
&lt;item&gt;72&lt;/item&gt;
&lt;item&gt;168&lt;/item&gt;
&lt;item&gt;720&lt;/item&gt;
&lt;/string-array&gt;
</code></pre>

<p>In addition, the <code>onBuildHeaders</code> function is overridden to reference the <code>settings_headers.xml</code>:</p>

<pre><code>&lt;preference-headers&gt;
  &lt;header/&gt;
&lt;/preference-headers&gt;
</code></pre>

<p>which references a single preference header, implemented by the <code>GraphSettingsFragment</code> in the code. <br /><br />
Finally, the retrieved settings values are managed in a <code>GraphSettings</code> class used in the rest of the code.</p>

<h3 id="results"> Results</h3>

<p>The android widget looks like this:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/GraphViewerWidget/widget_screenshot.png" alt="widget screenshot" /></p>

<p>And integrated in <a href="http://jheyman.github.io/blog/pages/HomeHubTablet">home hub tablet</a>:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/GraphViewerWidget/integration_in_tablet.png" alt="integration" /></p>

<h3 id="lessons-learned">Lessons learned</h3>

<ul>
  <li>Android widget mechanics are slightly convoluted, and widgets are much more restricted (by design) than regular android apps. I gave up on finding a robust way to get the current size of the widget programmatically, and with this Android API version.</li>
  <li>I still like them better for this kind of use though (and deriving a 2nd widget is easy once the initial effort has been done)</li>
  <li>Manually rendering a custom bitmap via the Android Canvas API is easy enough for very simple graphics like this.</li>
  <li>For storing and retrieving timestamped data efficiently, do yourself a favor and use a time-series database instead of a general purpose database</li>
</ul>

				</div><!-- entry-content -->

				<br>
				<hr>
				<div class="misc-content">			
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'jheymantechblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




				</div><!-- misc-content -->				
			</div><!-- bd -->

			<footer class="unit-foot">
				<div class="unit-inner unit-foot-inner">
					<p class="gotop">
						<a href="#page">Back to Top</a>
					</p>
				</div>
			</footer>

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>


				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
	</div><!-- body -->
	<footer class="the-footer">
		<div class="unit-foot">
			<div class="unit-inner unit-foot-inner">
				<div class="misc vcard">
					<h4>about</h4>
					<ul>
						<li class="contact"><address><span class="author fn n">JH</span> - <span class="fn email">bidsomail at gmail.com</span></address></li>
						<li>Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>, theme based on the_minimum from <a href="http://jekyllbootstrap.com/">Jekyll-bootstrap</a></li>
					</ul>
				</div><!-- misc -->
			</div><!-- unit-foot-inner -->
		</div><!-- unit-foot -->
	</footer>
</div><!-- page -->
<script>
	(function(d, s) {
		var js, fjs = d.getElementsByTagName(s)[0], load = function(url, id) {
		if (d.getElementById(id)) {return;}
		js = d.createElement(s); js.src = url; js.id = id;
		fjs.parentNode.insertBefore(js, fjs);
		};
	load('//platform.twitter.com/widgets.js', 'tweetjs');
	// load('https://apis.google.com/js/plusone.js', 'gplus1js'); // Checkout http://j.mp/ApDgMr for usage html for this is <div class="g-plusone" data-size="medium"></div>
	// load('//connect.facebook.net/en_US/all.js#xfbml=1', 'fbjssdk'); // Checkout http://j.mp/wZw2xR for using open graph protorol html for this is <div class="fb-like" data-href="/pages/GraphViewerWidget/index.html" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="verdana"></div>
	}(document, 'script'));
</script>
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>

  


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-43264312-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



</body>
</html>

