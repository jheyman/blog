
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Multi-Room Home Audio</title>
	<meta name="author" content="Julien Heyman">
	<link href='http://jheyman.github.io/blog/assets/themes/mytheme/css/style.css' rel="stylesheet" media="all">
	<link rel="alternate" type="application/rss+xml" title="" href="http://jheyman.github.io/blog/feed.xml">
	<script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<a href="http://jheyman.github.io/blog/index.html"><img src="http://jheyman.github.io/blog/assets/images/common/hotglue_and_homemade_bits.png" height="100%" class="center" /></a>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					
<article class="unit-article layout-page">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Multi-Room Home Audio</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					<p>The purpose of this project was to have music available in several rooms at home, while being able to control everything either centrally or locally. The convenient (and extremely expensive) way is to go for a Sonos system. The cheap and fun way is, as usual, to use raspberry pi boards. Three main elements are involved:</p>

<ul>
<li>a (single) central audio streaming server</li>

<li>one audio player/client per room to be equipped</li>

<li>a user interface <br /><br /> For the <strong>audio server</strong>, my home&#8217;s main raspberry pi sounded like the default choice. There are plenty of SW options to choose from, I chose to use the well-known (if somewhat ageing) <code>Logitech Media Server</code> open source music server. An alternative could have been to use <code>minidlna</code> + <code>BubbleUPnP</code>. For media content storage, anything from a simple USB thumbdrive to a full-fledged NAS will do the job, depending on your needs. I chose to use a 500GB HDD USB external drive.<br /><br /></li>
</ul>

<p>For the <strong>audio player/client</strong> part, given the choice of LMS as the server, the <code>squeezelite</code> client was a logical choice. On the HW side, since the embedded audio output on the pi is pretty low-end, a simple USB DAC will provide a decent sound quality, which I consider to be OK. Audiophiles may prefer to go for a higher-end sound card for the Pi, e.g. HifiBerry or Wolfson. I am not too fond of custom raspberry pi add-ons like these for a specific reason: their connector typically take up most if not all of the pi&#8217;s GPIO pins, making them unavailable for other purposes. Finally, since I wanted to use large external speakers beyond what a USB DAC can drive, I added an audio amplification board from Adafruit. There are cheaper options but the adafruit module is quite convenient with its 20W amplification, 3.5mm jack input, terminal blocks for speaker outputs, and has digital volume control available through I2C. <br /><br /></p>

<p>For the <strong>system control/user interface</strong>, the usual way is to rely on LMS web interface, or the corresponding phone app. I do have a logical place to access this from (<a href='http://jheyman.github.io/blog/pages/HomeHubTablet'>HomeHub</a>), but somehow it did not feel very convenient to have to go to the wall-mounted tablet to control the music, and since I do not carry my smartphone at all times it was not a convenient choice either. So I went for the old-style option : a remote control. A small &amp; thin IR remote control costs a few bucks only, same goes for an IR receiver diode. On the SW side, the <code>LIRC</code> library is perfect to decode commands from the remote, and the <code>pyLIRC</code> python wrapper for LIRC provides a convenient API (a C program would be fine too, but I&#8217;m lazy)<br /><br /></p>

<p>Here&#8217;s an overview of the system:</p>

<p><img alt='overview' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/global_overview.png' /></p>

<p>Required components are (per room to be equipped):</p>

<ul>
<li>a Raspberry pi and its SD card (4GB min)</li>

<li>a 5V power supply for the pi</li>

<li>a USB sound card (3$ at <a href='http://dx.com/p/5-1-channel-usb-sound-card-adapter-blue-59037#.Uyx0enX5PZg'>DealExtreme</a>)</li>

<li>a wifi USB dongle (6$ at <a href='http://dx.com/p/dx-original-ultra-mini-usb-2-0-802-11n-b-g-150mbps-wi-fi-wlan-wireless-network-adapter-black-252716#.Uyx3FXX5PZg'>DealExtreme</a>)</li>

<li>an audio amplifier module (20W model, 20$ from <a href='https://learn.adafruit.com/adafruit-20w-stereo-audio-amplifier-class-d-max9744/overview'>Adafruit</a>) <img alt='amplifier' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/adafruit_audioamp.png' /></li>

<li>a 12V / 2A power supply for the amplifier board</li>

<li>a couple of speakers <img alt='speaker' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/speakers.png' /></li>

<li>a cheap IR remote (2$ at <a href='http://www.dx.com/p/mcu-development-board-21-button-remote-control-1-x-cr2025-132290#.VKhdE3WG-zc'>DealExtreme</a>) <img alt='remote' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/remote.png' /></li>

<li>an IR receiver: a TSOP31238 I happened to have as a spare part <img alt='IR receiver' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/TSOP31238.png' /></li>
</ul>

<p>The overall cost comes down to about 70$ per room, which is not dirt cheap but still significantly lower than any commercial solution out there.</p>

<h3 id='raspberry_pi_setup_server_side'>Raspberry pi setup: SERVER side</h3>

<p>As usual, everything begins with installing a default Raspbian distribution from raspberrypi.org</p>

<p>1) transfer raspbian image to SD card:</p>

<pre><code>sudo dd bs=1M if=XXX-raspbian.img of=/dev/xxx</code></pre>

<p>2) plug-in a mouse/keyboard/HDMI display and boot-up</p>

<p>3) Use <code>raspi-config</code> to configure the raspberry as required (e.g. keyboard layout)</p>

<p>4) Plug wi-fi dongle, boot to graphical environment, configure wifi settings.</p>

<h4 id='installing_logitech_media_server'>Installing Logitech Media Server</h4>

<p>Install notes are taken from <a href='http://allthingspi.webspace.virginmedia.com/lms.php'>here</a> and reused as is, except that LMS 7.7.3 is used:</p>

<pre><code>sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade 
sudo apt-get install libjpeg8 libpng12-0 libgif4 libexif12 libswscale2 libavcodec53
wget http://downloads.slimdevices.com/LogitechMediaServer_v7.7.3/logitechmediaserver_7.7.3_all.deb 
sudo dpkg -i logitechmediaserver_7.7.3_all.deb
sudo service logitechmediaserver stop
wget http://allthingspi.webspace.virginmedia.com/files/lms-rpi-raspbian.tar.gz 
tar -zxvf lms-rpi-raspbian.tar.gz
sudo patch /usr/share/perl5/Slim/bootstrap.pm lms-rpi-bootstrap.patch
sudo mv arm-linux-gnueabihf-thread-multi-64int /usr/share/squeezeboxserver/CPAN/arch/5.14/ 
sudo mv libmediascan.so.0.0.0 libfaad.so.2.0.0 /usr/local/lib 
sudo mv /usr/share/squeezeboxserver/Bin/arm-linux/faad /usr/share/squeezeboxserver/Bin/arm-linux/faad.old 
sudo mv faad /usr/share/squeezeboxserver/Bin/arm-linux 
sudo ln -s /usr/local/lib/libmediascan.so.0.0.0 /usr/local/lib/libmediascan.so 
sudo ln -s /usr/local/lib/libmediascan.so.0.0.0 /usr/local/lib/libmediascan.so.0 
sudo ln -s /usr/local/lib/libfaad.so.2.0.0 /usr/local/lib/libfaad.so 
sudo ln -s /usr/local/lib/libfaad.so.2.0.0 /usr/local/lib/libfaad.so.2 
sudo ldconfig
sudo chown -R squeezeboxserver:nogroup /usr/share/squeezeboxserver/
sudo service logitechmediaserver start</code></pre>

<h4 id='setting_up_media_storage'>Setting up media storage</h4>

<p>Create a directory to mount USB on:</p>

<pre><code>sudo mkdir /media/usb</code></pre>

<p>Edit <code>/etc/fstab</code> to automount the USB drive at boot:</p>

<pre><code>sudo nano /etc/fstab</code></pre>

<p>And add line:</p>

<pre><code>/dev/sda1 /media/usb vfat uid=pi,gid=pi,umask=0022,sync,auto,nosuid,rw,nouser 0 0</code></pre>

<p>(<code>/dev/sda1</code> is how my USB drive is detected, your mileage may vary, check with <code>sudo fdisk -l</code>)</p>

<h3 id='raspberry_pi_setup_client_side'>Raspberry pi setup: CLIENT side</h3>

<p>Just like on the server, install a default Raspbian image</p>

<p>1) transfer raspbian image to SD card:</p>

<pre><code>sudo dd bs=1M if=XXX-raspbian.img of=/dev/xxx</code></pre>

<p>2) plug-in a mouse/keyboard/HDMI display and boot-up</p>

<p>3) Use <code>raspi-config</code> to configure the raspberry as required (e.g. keyboard layout)</p>

<p>4) Plug wi-fi dongle, boot to graphical environment, configure wifi settings.</p>

<p>Also install a telnet client, it will be used to connect to the media server:</p>

<pre><code>sudo apt-get install telnet</code></pre>

<h4 id='audio_setup'>Audio setup</h4>

<p>Plug &amp; configure USB sound card. In my case with this USB model it boiled down to:</p>

<pre><code>sudo nano /etc/modprobe.d/alsa-base.conf</code></pre>

<p>changing:</p>

<pre><code>options snd-usb-audio index=-2</code></pre>

<p>into:</p>

<pre><code>options snd-usb-audio index=0</code></pre>

<h4 id='installing_squeezelite'>Installing squeezelite</h4>

<p>Squeezelite is an open source squeezebox (i.e. Logitech original commercial audio player) emulator, using ALSA for audio output. It will connect to the Logitech Media Server, and enable local audio playback of remote media stored on the LMS. Installation steps are borrowed from <a href='http://www.gerrelt.nl/RaspberryPi/wordpress/tutorial-installing-squeezelite-player-on-raspbian/'>here</a></p>

<pre><code>sudo apt-get install -y libflac-dev libfaad2 libmad0
wget http://squeezelite-downloads.googlecode.com/git/squeezelite-armv6hf
sudo mv squeezelite-armv6hf /usr/bin
sudo chmod a+x /usr/bin/squeezelite-armv6hf</code></pre>

<p>List the available audio devices, using the command <code>squeezelite-armv6hf -l</code>:</p>

<pre><code>Output devices:
  null                           - Discard all samples (playback) or generate zero samples (capture)
  default:CARD=Set               - C-Media USB Headphone Set, USB Audio - Default Audio Device
  sysdefault:CARD=Set            - C-Media USB Headphone Set, USB Audio - Default Audio Device
  front:CARD=Set,DEV=0           - C-Media USB Headphone Set, USB Audio - Front speakers
  surround40:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 4.0 Surround output to Front and Rear speakers
  surround41:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 4.1 Surround output to Front, Rear and Subwoofer speakers
  surround50:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 5.0 Surround output to Front, Center and Rear speakers
  surround51:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 5.1 Surround output to Front, Center, Rear and Subwoofer speakers
  surround71:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
  iec958:CARD=Set,DEV=0          - C-Media USB Headphone Set, USB Audio - IEC958 (S/PDIF) Digital Audio Output
  default:CARD=ALSA              - bcm2835 ALSA, bcm2835 ALSA - Default Audio Device
  sysdefault:CARD=ALSA           - bcm2835 ALSA, bcm2835 ALSA - Default Audio Device</code></pre>

<p>The <code>bcm2835</code> entries correspond to the raspiberry pi internal audio. In my case, the audio output from the USB sound card corresponds to <code>front:CARD=Set,DEV=0</code><br /><br /></p>

<p>Let&#8217;s now make squeezelite start automatically at boot as a daemon. <a href='http://www.gerrelt.nl/RaspberryPi/squeezelitehf.sh'>Gerrelt&#8217;s script</a> will do fine.<br /><br /></p>

<p>Edit the file:</p>

<pre><code>sudo nano squeezelitehf.sh</code></pre>

<p>and adjust the following parameter to select the USB audio output:</p>

<pre><code>SL_SOUNDCARD=&quot;front:CARD=Set,DEV=0&quot;</code></pre>

<p>I stored my custom version <a href='https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/squeezelite'>here</a>.<br /><br /></p>

<p>Finally, move it to the proper location and request it to be added as a daemon</p>

<pre><code>sudo mv squeezelitehf.sh /etc/init.d/squeezelite
sudo chmod a+x /etc/init.d/squeezelite
sudo update-rc.d squeezelite defaults</code></pre>

<p>At the next reboot, squeezelite client will be running in the background, ready to play music.</p>

<h4 id='i2c_setup'>I2C setup</h4>

<p>We must first enable the I2C interface on the Raspberry:</p>

<pre><code>sudo nano /etc/modprobe.d/raspi-blacklist.conf</code></pre>

<p>comment out the following line (with a <code>#</code>)</p>

<pre><code>blacklist i2c-bcm2708</code></pre>

<p>then edit /etc/modules:</p>

<pre><code>sudo nano /etc/modules</code></pre>

<p>and add the line:</p>

<pre><code>i2c-dev</code></pre>

<p>To enable access to /dev/i2C without root permissions, create a custom rule file:</p>

<pre><code>sudo nano /etc/udev/rules.d/99-i2c.rules</code></pre>

<p>and fill it with this content:</p>

<pre><code>SUBSYSTEM==\&quot;i2c-dev\&quot;, MODE=\&quot;0666\&quot;    </code></pre>

<p>Installing the i2C tools will turn out to be useful, as well as the python binding to access i2C:</p>

<pre><code>sudo aptitude install i2c-tools python-smbus</code></pre>

<p>Finally, reboot the pi:</p>

<pre><code>sudo reboot</code></pre>

<h4 id='installing_lirc'>Installing LIRC</h4>

<p>To install the LIRC (Linux Infrared Remote Control) library that allows to read the TSOP IR receiver:</p>

<pre><code>sudo apt-get install lirc liblircclient-dev</code></pre>

<p>Then:</p>

<pre><code>sudo nano /etc/modules</code></pre>

<p>Add the following two lines:</p>

<pre><code>lirc_dev
lirc_rpi gpio_in_pin=18</code></pre>

<p>Ajust the LIRC hardware config file:</p>

<pre><code>sudo nano /etc/lirc/hardware.conf </code></pre>

<p>to match the following content:</p>

<pre><code># /etc/lirc/hardware.conf
#
# Arguments which will be used when launching lircd
LIRCD_ARGS=&quot;--uinput&quot;
 
# Don&#39;t start lircmd even if there seems to be a good config file
# START_LIRCMD=false
 
# Don&#39;t start irexec, even if a good config file seems to exist.
# START_IREXEC=false
 
# Try to load appropriate kernel modules
LOAD_MODULES=true
 
# Run &quot;lircd --driver=help&quot; for a list of supported drivers.
DRIVER=&quot;default&quot;
# usually /dev/lirc0 is the correct setting for systems using udev
DEVICE=&quot;/dev/lirc0&quot;
MODULES=&quot;lirc_rpi&quot;
 
# Default configuration files for your hardware if any
LIRCD_CONF=&quot;&quot;
LIRCMD_CONF=&quot;&quot;</code></pre>

<p>and reboot:</p>

<pre><code>sudo reboot</code></pre>

<h3 id='testing_lms__squeezelite'>Testing LMS &amp; Squeezelite</h3>

<p>To check that everything is in order, let&#8217;s check audio streaming (you can just plug a set of earphones at the USB DAC output for now). In this project the squeezelite client is launched at boot as a daemon. But if this not the case, one can launch it manually:</p>

<pre><code>squeezelite-armv6hf -s {IP address of the pi hosting LMS}</code></pre>

<p>The LMS web interface can be accessed at: <code>http://{IP address of the pi hosting LMS}:9000</code>, and from there it is possible to control audio playback on the client raspberry. At initial launch, an installation wizard is executed, just tell it where your music is (in my case: on the USB drive at <code>/media/usb/music</code>). If the installation was ok, you should be able to play music on the client pi at this point.</p>

<h3 id='cabling_overview'>Cabling overview</h3>

<p>Let&#8217;s now add audio amplification and remote control. The different elements will be connected as depicted below:</p>

<p><img alt='Cabling overview' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/cabling.png' /></p>

<ul>
<li>To amplifier: GND, VI2C, SDA and SCL are the required connections for I2C communication with the amplifier to digitally adjust gain/volume. In addition, the SHDN (Shutdown) pin of the amplifier is connected to one of the pi&#8217;s GPIO, so as to be able to disable the amplifier when not used.</li>

<li>To TSOP IR receiver: GND, VCC, and SIGNAL (connected to the pi&#8217;s GPIO #18, as configured in LIRC)<br /><br /></li>
</ul>

<p>Here is a work-in-progress view:</p>

<p><img alt='audio_setup' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/audio_setup.png' /></p>

<h3 id='communicating_with_the_amplifier_module'>Communicating with the amplifier module</h3>

<p>The raspberry will control the amplifier module through its I2C interface, a.k.a. 2-Wire. Communication happens over two lines:</p>

<ul>
<li>SDA: Serial DAta</li>

<li>SCL: Serial CLock</li>
</ul>

<p>In addition to these two pins and the GND, the reference voltage for I2C communication shall also be provided to the amplifier: just connect one of the raspi 5V pins to the amp&#8217;s VI2C pin.</p>

<p>Scan the bus, the amp should be detected at address 0x4B:</p>

<pre><code>sudo i2cdetect -y 1

     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- 4b -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- --   </code></pre>

<p>The protocol to communicate with the amplifier module is extremely simple : just write a volume value between 0x0 and 0x3F (63 is the max value, since volume is coded on 6 bits), at address 0x4B. For example to set volume to the medium value:</p>

<pre><code>sudo i2cset -y 1 0x4B 0x20</code></pre>

<h4 id='configuring_ir_remotereceiver'>Configuring IR remote/receiver</h4>

<p>First, let&#8217;s stop the LIRC daemon since we will be accessing the LIRC input device for these tests:</p>

<pre><code>sudo /etc/init.d/lirc stop</code></pre>

<p>To check that cabling is correct and TSOP is working properly:</p>

<pre><code>mode2 -d /dev/lirc0</code></pre>

<p>When pressing buttons on the remote, you should see messages (&#8220;pulse xxx space yyy&#8221;) being displayed.<br /><br /> Next, we need to generate the config file associated to our remote:</p>

<pre><code>irrecord -d /dev/lirc0 -f lircd.conf</code></pre>

<p><strong>Note</strong>: the <code>-f</code> option is normally not necessary. It worked fine without this option with one kind of remote I had, but I had to add it for the specific model of remote I finally used, otherwise I was getting an error &#8220;Something went wrong&#8221; during the irrecord setup process. <br /><br /></p>

<p>This will guide you through a sequence of actions with the remote. First, a detection is performed by just pressing various buttons on the remote repeatedly. In the end, you will be requested to map the key codes (which names are available by executing: <code>irrecord --list-namespace</code>), and to press the corresponding button on the remote.<br /><br /></p>

<p>In my case, I mapped the following names/buttons:</p>

<pre><code>KEY_POWER
KEY_MUTE
KEY_KPPLUS
KEY_KPMINUS
KEY_PLAY
KEY_NEXT
KEY_PREVIOUS
KEY_1
KEY_2
KEY_3
KEY_4
KEY_5
KEY_6
KEY_7
KEY_8
KEY_9</code></pre>

<p>Edit the generated <code>lircd.conf</code> file and provide a name for your remote (e.g. &#8220;piremote&#8221;). Then copy the file to its official location:</p>

<pre><code>sudo cp lircd.conf /etc/lirc/lircd.conf</code></pre>

<p>Relaunch the LIRC daemon</p>

<pre><code>sudo /etc/init.d/lirc restart</code></pre>

<p>To test that key presses are properly taken into account, you can execute <code>irw</code> and push some buttons on the remote: the corresponding key codes shall be displayed.</p>

<h4 id='controlling_the_audio_playback'>Controlling the audio playback</h4>

<p>The LMS has a command line interface that can be leveraged to remotely control audio playback: just telnet into the server pi on port 9090, and use the LMS CLI format. Here are a few one-liner examples:<br /><br /></p>

<p>Play:</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] play&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>Pause/play toggle:</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] pause&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>Stop:</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] stop&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>Adjust volume:</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] mixer volume -10&quot; | telnet [IP address of the raspi running LMS] 9090
echo &quot;[MAC address of the squeezelite player] mixer volume +10&quot; | telnet [IP address of the raspi running LMS] 9090
echo &quot;[MAC address of the squeezelite player] mixer volume 50&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>Mute/unmute toggle :</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] mixer muting&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>Next song in playlist:</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] playlist index +1&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>Previous song in playlist:</p>

<pre><code>echo &quot;[MAC address of the squeezelite player] playlist index -1&quot; | telnet [IP address of the raspi running LMS] 9090</code></pre>

<p>For a basic use, just binding remote control commands from LIRC to some of these actions will work just fine, just configure the LIRC daemon to associate specific actions to each key code. This is achieved (for example) by creating a global <code>lircrc</code> file in <code>/etc/lirc</code>:</p>

<pre><code>sudo nano /etc/lirc/lircrc</code></pre>

<p>Below is an example content I experimented with at some point:</p>

<pre><code>begin
    prog = irexec
    remote = piremote
    button = KEY_POWER
    config = echo &quot;not implemented yet&quot;
end

begin
    prog = irexec
    remote = piremote
    button = KEY_MUTE
    config = echo &quot;80:1f:02:65:39:47 mixer muting&quot; | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_KPPLUS
    config = echo &quot;80:1f:02:65:39:47 mixer volume +5&quot; | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_KPMINUS
    config = echo &quot;80:1f:02:65:39:47 mixer volume -5&quot; | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_PLAY
    config = echo &quot;80:1f:02:65:39:47 pause&quot; | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_NEXT
    config = echo &quot;80:1f:02:65:39:47 playlist index +1&quot; | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_PREVIOUS
    config = echo &quot;80:1f:02:65:39:47 playlist index -1&quot; | telnet 192.168.0.45 9090
end</code></pre>

<h4 id='installing_pylirc'>Installing PyLIRC</h4>

<p>Even though the <code>lircrc</code> config allows to define actions to be executed for each button, I needed a bit more flexibility: for example to implement a stateful audio controller that keeps track of current volume, or that I could turn on / turn off using a single button. Luckily, there is a Python binding for LIRC available: PyLIRC2. Installation goes like this:<br /><br /></p>

<p>1) get PyLIRC2 from <code>https://pypi.python.org/pypi/pylirc2</code></p>

<p>2) uncompress it:</p>

<pre><code>tar xvzf pylirc2-0.1.tar.gz </code></pre>

<p>3) launch install script:</p>

<pre><code>cd pylirc2-0.1/
sudo python setup.py install</code></pre>

<p>4) create a python controller script and associated config file:</p>

<ul>
<li>the config file reuses the <code>lircrc</code> format</li>

<li>the controller script is homemade and very basic: it just polls pylirc for incoming commands received from the IR receiver (using the blocking mode to avoid spinning CPU for nothing), and launches a telnet command on the LMS accordingly.<br /><br /></li>
</ul>

<p>On the server side, 9 playlists named <code>playlist_xx.m3u</code> are stored in the media folder, and pressing buttons 1 to 9 on the remote trigs one of these playlists. I mapped a few albums to some of the 9 buttons, and web radios to the others. The playlist format (m3u) is very basic, it boils down to one entry per line with the path to a song. A convenient way to generate a playlist corresponding to a full album is:</p>

<pre><code>find /home/pi/music/SomeAlbumName/ -name *.mp3 | sort &gt; playlist.m3u</code></pre>

<p>A few specific details were implemented in the controller:</p>

<ul>
<li>on/off management: when turning the player on/off, an audio confirmation was added. Indeed, in my case the audio client pi is hidden in the ceiling, with no visible mean to check if the system is currently on or off. So I just play a small audio jingle when turning the player on, and a different jingle when turning it off. Also, upon OFF (respectively ON) command, the shutdown GPIO is set to low (respectively high) so that the audio amplifier goes to (respectively exits) shutdown/ultra low power mode.</li>

<li>error management: since the pi hosting this code will not be easily accessible once installed, I added various checks &amp; try/repeat loops to handle error cases, so that the script is as robust as possible to error conditions.</li>
</ul>

<p>My config file is available <a href='https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/conf'>here</a>, and <a href='https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/audioController.py'>here&#8217;s</a> the controller code. The script uses an external configuration file to store the server IP address and its own MAC address, as well as the path to the file when outputs are logged.</p>

<h3 id='automate_launch_at_pi_startup'>Automate launch at Pi startup</h3>

<p>Once everything worked as expected, I proceeded with automating the execution of the audio controller script at startup. I chose to turn it into a background service/daemon, using <a href='http://blog.scphillips.com/2013/07/getting-a-python-script-to-run-in-the-background-as-a-service-on-boot/'>these</a> great instructions. My version is available <a href='https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/audiocontroller.sh'>here</a>, I just added the <code>--chdir</code> option in the <code>start-stop-daemon</code> command to set the working directory of the service to be the one the script and its associated files are stored in, so that no absolute paths need to be specified inside the script. Just copy this script to <code>/etc/init.d</code>, make sure it has execution rights, then add activate this service using:</p>

<pre><code>sudo update-rc.d audiocontroller.sh defaults</code></pre>

<p>Reboot the pi: traces of the successful execution of the audio controller script should be visible in <code>/tmp/audiocontroller.log</code> file.<br /><br /></p>

<p>NOTE: in my case, it&#8217;s a good thing I inserted a check &amp; retry loop on pinging the LMS server at the beginning of the script, since the wifi connection does not come up immediately at startup, and the script would otherwise exit in error.<br /><br /></p>

<p>Final touch: since at least one of the client pi is installed in my attic, I wanted to be able to power-cycle it in case of errors. To achieve this, I just plugged the pi power supply on a Z-Wave relay, that can be turned off/on remotely. See <a href='http://jheyman.github.io/blog/pages/ZwaveHomeAutomation'>ZwaveHomeAutomation</a> project for details.</p>

<h3 id='physical_installation'>Physical installation</h3>

<p>With everything up and running, I proceeded with installing the system in one of the rooms. I bought a couple of small ceiling-mountable speakers, here is what one of them looks like after being installed:</p>

<p><img alt='speaker in ceiling' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/speaker_installed.png' /></p>

<p>Regarding the IR receiver, there was no convenient way to hide it somewhere in the room, so I chose another appraoch: buying a ceiling-mountable presence sensor, getting rid of the electronics inside, and installing my IR receiver diode instead. Basically I just reused the casing. Here it is:</p>

<p><img alt='IR_shell' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/IR_shell.png' /></p>

<p>And here is the IR receiver soldered onto the front of the (now totally useless) PCB. The three leads are soldered onto an existing output connector of the module:</p>

<p><img alt='IR_receiver_in_shell' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/IR_receiver_in_shell.png' /></p>

<p>Finally, here it is installed on the ceiling:</p>

<p><img alt='IR_shell_installed' src='http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/IR_shell_installed.png' /></p>

<h3 id='installing_in_additional_rooms'>Installing in additional rooms</h3>

<p>The exact same steps as above can be used to install additional players in other rooms, the only required modification is to change the MAC address in the audio controller config file. Wash, rinse and repeat.</p>

<h3 id='misc'>Misc</h3>

<ul>
<li>I was a bit concerned regarding the amount of CPU power required to run the audio server and clients. As it turns out, streaming audio LMS takes less than 3% CPU time on the server, while on the client side squeezelite takes about 10% CPU time. So no big deal in either case, both the server and the client pi&#8217;s can handle a lot of additional functions.</li>
</ul>

<h3 id='todo'>Todo</h3>

<p>I&#8217;d like to leverage the newly added audio capabilty in each equipped room for at least two other purposes:</p>

<ul>
<li>playing audio reminders at predefined times (from google calendar entries + voice synthesis) =&gt; done, see <a href='http://jheyman.github.io/blog/pages/GoogleCalendarAudioNotifier'>this project</a></li>

<li>adding a microphone to the setup, in order to use the client pi as intercom endpoints between rooms.</li>
</ul>

<h3 id='lessons_learned'>Lessons learned</h3>

<ul>
<li>for once, everything went smoothly: IR remote control with LIRC is a breeze to setup and use, the pi is easy as ever to setup, and controlling the audio amplifier through I2C and GPIOs worked the first time.</li>

<li>I realized that sometimes, just pushing a button on a remote is way more convenient than grabbing you phone, unlocking it, navigating to a specific app, opening it, and finally clicking somewhere.</li>

<li>2x20W amplification is plenty enough for small rooms, I never had to turn the volume all the way up, by far. A different approach with be required for the living room audio though.</li>
</ul>
				</div><!-- entry-content -->

				<br>
				<hr>
				<div class="misc-content">			
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'jheymantechblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




				</div><!-- misc-content -->				
			</div><!-- bd -->

			<footer class="unit-foot">
				<div class="unit-inner unit-foot-inner">
					<p class="gotop">
						<a href="#page">Back to Top</a>
					</p>
				</div>
			</footer>

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>


				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
	</div><!-- body -->
	<footer class="the-footer">
		<div class="unit-foot">
			<div class="unit-inner unit-foot-inner">
				<div class="misc vcard">
					<h4>about</h4>
					<ul>
						<li class="contact"><address><span class="author fn n">Julien Heyman</span> - <span class="fn email">bidsomail at gmail.com</span></address></li>
						<li>Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>, theme based on the_minimum from <a href="http://jekyllbootstrap.com/">Jekyll-bootstrap</a></li>
					</ul>
				</div><!-- misc -->
			</div><!-- unit-foot-inner -->
		</div><!-- unit-foot -->
	</footer>
</div><!-- page -->
<script>
	(function(d, s) {
		var js, fjs = d.getElementsByTagName(s)[0], load = function(url, id) {
		if (d.getElementById(id)) {return;}
		js = d.createElement(s); js.src = url; js.id = id;
		fjs.parentNode.insertBefore(js, fjs);
		};
	load('//platform.twitter.com/widgets.js', 'tweetjs');
	// load('https://apis.google.com/js/plusone.js', 'gplus1js'); // Checkout http://j.mp/ApDgMr for usage html for this is <div class="g-plusone" data-size="medium"></div>
	// load('//connect.facebook.net/en_US/all.js#xfbml=1', 'fbjssdk'); // Checkout http://j.mp/wZw2xR for using open graph protorol html for this is <div class="fb-like" data-href="/pages/MultiRoomHomeAudio/index.html" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="verdana"></div>
	}(document, 'script'));
</script>
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>

 


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-43264312-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



</body>
</html>

