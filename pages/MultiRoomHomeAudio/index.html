
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Multi-Room Home Audio</title>
	<meta name="author" content="Julien Heyman">
	<link href='http://jheyman.github.io/blog/assets/themes/mytheme/css/style.css' rel="stylesheet" media="all">
	<link href="http://feeds.feedburner.com/" rel="alternate" title="Multi-Room Home Audio" type="application/atom+xml">
	<script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<a href="http://jheyman.github.io/blog/index.html"><img src="http://jheyman.github.io/blog/assets/images/common/hotglue_and_homemade_bits.png" height="100%" class="center" /></a>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					
<article class="unit-article layout-page">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Multi-Room Home Audio</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					
<p>The purpose of this project was to have music available in several rooms at home, while being able to control everything either centrally or locally. The convenient (and extremely expensive) way is to go for a Sonos system. The cheap and fun way is, as usual, to use raspberry pi boards. Three main elements are involved:</p>

<ul>
  <li>a (single) central audio streaming server</li>
  <li>one audio player/client per room to be equipped</li>
  <li>a user interface</li>
</ul>

<p><br />For the <strong>audio server</strong>, my home&#8217;s main raspberry pi sounded like the default choice. There are plenty of SW options to choose from, I chose to use the well-known (if somewhat ageing) <code>Logitech Media Server</code> open source music server. An alternative could have been to use <code>minidlna</code> + <code>BubbleUPnP</code>. For media content storage, anything from a simple USB thumbdrive to a full-fledged NAS will do the job, depending on your needs. I chose to use a 500GB HDD USB external drive.<br /><br /></p>

<p>For the <strong>audio player/client</strong> part, given the choice of LMS as the server, the <code>squeezelite</code> client was a logical choice. On the HW side, since the embedded audio output on the pi is pretty low-end, a simple USB DAC will provide a decent sound quality, which I consider to be OK. Audiophiles may prefer to go for a higher-end sound card for the Pi, e.g. HifiBerry or Wolfson. I am not too fond of custom raspberry pi add-ons like these for a specific reason: their connector typically take up most if not all of the pi&#8217;s GPIO pins, making them unavailable for other purposes. Finally, since I wanted to use large external speakers beyond what a USB DAC can drive, I added an audio amplification board from Adafruit. There are cheaper options but the adafruit module is quite convenient with its 20W amplification, 3.5mm jack input, terminal blocks for speaker outputs, and has digital volume control available through I2C.
<br /><br /></p>

<p>For the <strong>system control/user interface</strong>, the usual way is to rely on LMS web interface, or the corresponding phone app. I do have a logical place to access this from (<a href="http://jheyman.github.io/blog/pages/HomeHubTablet">HomeHub</a>), but somehow it did not feel very convenient to have to go to the wall-mounted tablet to control the music, and since I do not carry my smartphone at all times it was not a convenient choice either. So I went for the old-style option : a remote control. A small &amp; thin IR remote control costs a few bucks only, same goes for an IR receiver diode. On the SW side, the <code>LIRC</code> library is perfect to decode commands from the remote, and the <code>pyLIRC</code> python wrapper for LIRC provides a convenient API (a C program would be fine too, but I&#8217;m lazy)<br /><br /></p>

<p>Here&#8217;s an overview of the system:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/global_overview.png" alt="overview" /></p>

<p>Required components are (per room to be equipped):</p>

<ul>
  <li>a Raspberry pi and its SD card (4GB min)</li>
  <li>a 5V power supply for the pi</li>
  <li>a USB sound card (3$ at <a href="http://dx.com/p/5-1-channel-usb-sound-card-adapter-blue-59037#.Uyx0enX5PZg">DealExtreme</a>)</li>
  <li>a wifi USB dongle (6$ at <a href="http://dx.com/p/dx-original-ultra-mini-usb-2-0-802-11n-b-g-150mbps-wi-fi-wlan-wireless-network-adapter-black-252716#.Uyx3FXX5PZg">DealExtreme</a>)</li>
  <li>an audio amplifier module (20W model, 20$ from <a href="https://learn.adafruit.com/adafruit-20w-stereo-audio-amplifier-class-d-max9744/overview">Adafruit</a>)
<img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/adafruit_audioamp.png" alt="amplifier" /></li>
  <li>a 12V / 2A power supply for the amplifier board</li>
  <li>a couple of speakers
<img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/speakers.png" alt="speaker" /></li>
  <li>a cheap IR remote (2$ at <a href="http://www.dx.com/p/mcu-development-board-21-button-remote-control-1-x-cr2025-132290#.VKhdE3WG-zc">DealExtreme</a>)
<img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/remote.png" alt="remote" /></li>
  <li>an IR receiver: a TSOP31238 I happened to have as a spare part
<img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/TSOP31238.png" alt="IR receiver" /></li>
</ul>

<p>The overall cost comes down to about 70$ per room, which is not dirt cheap but still significantly lower than any commercial solution out there.</p>

<h3 id="raspberry-pi-setup-server-side">Raspberry pi setup: SERVER side</h3>

<p>As usual, everything begins with installing a default Raspbian distribution from raspberrypi.org</p>

<p>1) transfer raspbian image to SD card:</p>

<pre><code>sudo dd bs=1M if=XXX-raspbian.img of=/dev/xxx
</code></pre>

<p>2) plug-in a mouse/keyboard/HDMI display and boot-up</p>

<p>3) Use <code>raspi-config</code> to configure the raspberry as required (e.g. keyboard layout)</p>

<p>4) Plug wi-fi dongle, boot to graphical environment, configure wifi settings.</p>

<p>5) get up to date</p>

<pre><code>sudo apt-get update
</code></pre>

<h4 id="installing-logitech-media-server">Installing Logitech Media Server</h4>

<p>Install notes are taken from <a href="http://allthingspi.webspace.virginmedia.com/lms.php">here</a> and reused as is, except that LMS 7.7.3 is used:</p>

<pre><code>sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade 
sudo apt-get install libjpeg8 libpng12-0 libgif4 libexif12 libswscale2 libavcodec53
wget http://downloads.slimdevices.com/LogitechMediaServer_v7.7.3/logitechmediaserver_7.7.3_all.deb 
sudo dpkg -i logitechmediaserver_7.7.3_all.deb
sudo service logitechmediaserver stop
wget http://allthingspi.webspace.virginmedia.com/files/lms-rpi-raspbian.tar.gz 
tar -zxvf lms-rpi-raspbian.tar.gz
sudo patch /usr/share/perl5/Slim/bootstrap.pm lms-rpi-bootstrap.patch
sudo mv arm-linux-gnueabihf-thread-multi-64int /usr/share/squeezeboxserver/CPAN/arch/5.14/ 
sudo mv libmediascan.so.0.0.0 libfaad.so.2.0.0 /usr/local/lib 
sudo mv /usr/share/squeezeboxserver/Bin/arm-linux/faad /usr/share/squeezeboxserver/Bin/arm-linux/faad.old 
sudo mv faad /usr/share/squeezeboxserver/Bin/arm-linux 
sudo ln -s /usr/local/lib/libmediascan.so.0.0.0 /usr/local/lib/libmediascan.so 
sudo ln -s /usr/local/lib/libmediascan.so.0.0.0 /usr/local/lib/libmediascan.so.0 
sudo ln -s /usr/local/lib/libfaad.so.2.0.0 /usr/local/lib/libfaad.so 
sudo ln -s /usr/local/lib/libfaad.so.2.0.0 /usr/local/lib/libfaad.so.2 
sudo ldconfig
sudo chown -R squeezeboxserver:nogroup /usr/share/squeezeboxserver/
sudo service logitechmediaserver start
</code></pre>

<h4 id="setting-up-media-storage">Setting up media storage</h4>

<p>Create a directory to mount USB on:</p>

<pre><code>sudo mkdir /media/usb
</code></pre>

<p>Edit <code>/etc/fstab</code> to automount the USB drive at boot:</p>

<pre><code>sudo nano /etc/fstab
</code></pre>

<p>And add line:</p>

<pre><code>/dev/sda1 /media/usb vfat uid=pi,gid=pi,umask=0022,sync,auto,nosuid,rw,nouser 0 0
</code></pre>

<p>(<code>/dev/sda1</code> is how my USB drive is detected, your mileage may vary, check with <code>sudo fdisk -l</code>)</p>

<h3 id="raspberry-pi-setup-client-side">Raspberry pi setup: CLIENT side</h3>

<p>Just like on the server, install a default Raspbian image</p>

<p>1) transfer raspbian image to SD card:</p>

<pre><code>sudo dd bs=1M if=XXX-raspbian.img of=/dev/xxx
</code></pre>

<p>2) plug-in a mouse/keyboard/HDMI display and boot-up</p>

<p>3) Use <code>raspi-config</code> to configure the raspberry as required (e.g. keyboard layout)</p>

<p>4) Plug wi-fi dongle, boot to graphical environment, configure wifi settings.</p>

<p>Also install a telnet client, it will be used to connect to the media server:</p>

<pre><code>sudo apt-get install telnet
</code></pre>

<h4 id="audio-setup">Audio setup</h4>

<p>Plug &amp; configure USB sound card. In my case with this USB model it boiled down to:</p>

<pre><code>sudo nano /etc/modprobe.d/alsa-base.conf
</code></pre>

<p>changing:</p>

<pre><code>options snd-usb-audio index=-2
</code></pre>

<p>into:</p>

<pre><code>options snd-usb-audio index=0
</code></pre>

<h4 id="installing-squeezelite">Installing squeezelite</h4>

<p>Squeezelite is an open source squeezebox (i.e. Logitech original commercial audio player) emulator, using ALSA for audio output. It will connect to the Logitech Media Server, and enable local audio playback of remote media stored on the LMS. 
Installation steps are borrowed from <a href="http://www.gerrelt.nl/RaspberryPi/wordpress/tutorial-installing-squeezelite-player-on-raspbian/">here</a></p>

<pre><code>sudo apt-get install -y libflac-dev libfaad2 libmad0
wget http://squeezelite-downloads.googlecode.com/git/squeezelite-armv6hf
sudo mv squeezelite-armv6hf /usr/bin
sudo chmod a+x /usr/bin/squeezelite-armv6hf
</code></pre>

<p>List the available audio devices, using the command <code>squeezelite-armv6hf -l</code>:</p>

<pre><code>Output devices:
  null                           - Discard all samples (playback) or generate zero samples (capture)
  default:CARD=Set               - C-Media USB Headphone Set, USB Audio - Default Audio Device
  sysdefault:CARD=Set            - C-Media USB Headphone Set, USB Audio - Default Audio Device
  front:CARD=Set,DEV=0           - C-Media USB Headphone Set, USB Audio - Front speakers
  surround40:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 4.0 Surround output to Front and Rear speakers
  surround41:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 4.1 Surround output to Front, Rear and Subwoofer speakers
  surround50:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 5.0 Surround output to Front, Center and Rear speakers
  surround51:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 5.1 Surround output to Front, Center, Rear and Subwoofer speakers
  surround71:CARD=Set,DEV=0      - C-Media USB Headphone Set, USB Audio - 7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
  iec958:CARD=Set,DEV=0          - C-Media USB Headphone Set, USB Audio - IEC958 (S/PDIF) Digital Audio Output
  default:CARD=ALSA              - bcm2835 ALSA, bcm2835 ALSA - Default Audio Device
  sysdefault:CARD=ALSA           - bcm2835 ALSA, bcm2835 ALSA - Default Audio Device
</code></pre>

<p>The <code>bcm2835</code> entries correspond to the raspberry pi internal audio. In my case, the audio output from the USB sound card corresponds to <code>front:CARD=Set,DEV=0</code><br /><br /></p>

<p>Let&#8217;s now make squeezelite start automatically at boot as a daemon. <a href="http://www.gerrelt.nl/RaspberryPi/squeezelitehf.sh">Gerrelt&#8217;s script</a> will do fine.<br /><br /></p>

<p>Edit the file:</p>

<pre><code>sudo nano squeezelitehf.sh
</code></pre>

<p>and adjust the following parameter to select the USB audio output:</p>

<pre><code>SL_SOUNDCARD="front:CARD=Set,DEV=0"
</code></pre>

<p>I stored my custom version <a href="https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/squeezelite">here</a>.<br /><br /></p>

<p>Finally, move it to the proper location and request it to be added as a daemon</p>

<pre><code>sudo mv squeezelitehf.sh /etc/init.d/squeezelite
sudo chmod a+x /etc/init.d/squeezelite
sudo update-rc.d squeezelite defaults
</code></pre>

<p>At the next reboot, squeezelite client will be running in the background, ready to play music.</p>

<h4 id="sharing-the-usb-card-audio-output-optional">Sharing the USB card audio output (optional)</h4>

<p>One problem I encountered is that once squeezelite is configured this way, it will prevent any other service from using the same USB audio output. This has nothing to do with squeezelite itself, but with the ALSA sound library configuration. It may or may not be a limitation depending on the intended usage, and for this particular project alone this is not a problem, but since I wanted to host other services using audio on the same raspberry pi (e.g. <a href="http://jheyman.github.io/blog/pages/GoogleCalendarAudioNotifier">GoogleCalendarAudioNotifier</a>), I had to address this. To solve this issue, it is necessary to configure ALSA for sharing the sound output device, and this is achieved by activating the <code>dmix</code> plugin that will then combine the audio channels from different services/programs into a single audio output.<br /><br /></p>

<p>The configuration is two-fold, the first part consists in a custom ALSA configuration file, to be put in file <code>/etc/asound.conf</code>:</p>

<pre><code>pcm.dmixer {
    type dmix
    ipc_key 1024
    ipc_key_add_uid false
    ipc_perm 0666
    slave {
        pcm "hw:0,0"
        period_time 0
        period_size 1024
        buffer_size 8192
        rate 44100
    }

    bindings {
        0 0
        1 1
     }
}

pcm.dsp0 {
    type plug
    slave.pcm "dmixer"
}

pcm.!default {
    type plug
    slave.pcm "dmixer"
}

pcm.default {
    type plug
    slave.pcm "dmixer"
}

ctl.mixer0 {
    type hw
    card 0
}
</code></pre>

<p>This piece of configuration tells alsa to declare a &#8220;dmixer&#8221; device leveraging the dmix plugin, and to set it as the default device for audio output. The second part then consists in modifying the squeezelite configuration itself (<code>/etc/init.d/squeezelite</code>) to modify the SL_SOUNDCARD parameter:</p>

<pre><code>SL_SOUNDCARD="default" 
</code></pre>

<h4 id="i2c-setup">I2C setup</h4>

<p>We must first enable the I2C interface on the Raspberry:</p>

<pre><code>sudo nano /etc/modprobe.d/raspi-blacklist.conf
</code></pre>

<p>comment out the following line (with a <code>#</code>)</p>

<pre><code>blacklist i2c-bcm2708
</code></pre>

<p>then edit /etc/modules:</p>

<pre><code>sudo nano /etc/modules
</code></pre>

<p>and add the line:</p>

<pre><code>i2c-dev
</code></pre>

<p>To enable access to /dev/i2C without root permissions, create a custom rule file:</p>

<pre><code>sudo nano /etc/udev/rules.d/99-i2c.rules
</code></pre>

<p>and fill it with this content:</p>

<pre><code>SUBSYSTEM==\"i2c-dev\", MODE=\"0666\"    
</code></pre>

<p>Installing the i2C tools will turn out to be useful, as well as the python binding to access i2C:</p>

<pre><code>sudo aptitude install i2c-tools python-smbus
</code></pre>

<p>Finally, reboot the pi:</p>

<pre><code>sudo reboot
</code></pre>

<h4 id="installing-lirc">Installing LIRC</h4>

<p>To install the LIRC (Linux Infrared Remote Control) library that allows to read the TSOP IR receiver:</p>

<pre><code>sudo apt-get install lirc liblircclient-dev
</code></pre>

<p>Then:</p>

<pre><code>sudo nano /etc/modules
</code></pre>

<p>Add the following two lines:</p>

<pre><code>lirc_dev
lirc_rpi gpio_in_pin=18
</code></pre>

<p>Ajust the LIRC hardware config file:</p>

<pre><code>sudo nano /etc/lirc/hardware.conf 
</code></pre>

<p>to match the following content:</p>

<pre><code># /etc/lirc/hardware.conf
#
# Arguments which will be used when launching lircd
LIRCD_ARGS="--uinput --allow-simulate"
 
# Don't start lircmd even if there seems to be a good config file
# START_LIRCMD=false
 
# Don't start irexec, even if a good config file seems to exist.
# START_IREXEC=false
 
# Try to load appropriate kernel modules
LOAD_MODULES=true
 
# Run "lircd --driver=help" for a list of supported drivers.
DRIVER="default"
# usually /dev/lirc0 is the correct setting for systems using udev
DEVICE="/dev/lirc0"
MODULES="lirc_rpi"
 
# Default configuration files for your hardware if any
LIRCD_CONF=""
LIRCMD_CONF=""
</code></pre>

<p>and reboot:</p>

<pre><code>sudo reboot
</code></pre>

<h3 id="testing-lms--squeezelite">Testing LMS &amp; Squeezelite</h3>

<p>To check that everything is in order, let&#8217;s check audio streaming (you can just plug a set of earphones at the USB DAC output for now). In this project the squeezelite client is launched at boot as a daemon. 
But if this not the case, one can launch it manually:</p>

<pre><code>squeezelite-armv6hf -s {IP address of the pi hosting LMS}
</code></pre>

<p>The LMS web interface can be accessed at: <code>http://{IP address of the pi hosting LMS}:9000</code>, and from there it is possible to control audio playback on the client raspberry.
At initial launch, an installation wizard is executed, just tell it where your music is (in my case: on the USB drive at <code>/media/usb/music</code>). If the installation was ok, you should be able to play music on the client pi at this point.</p>

<h3 id="cabling-overview">Cabling overview</h3>

<p>Let&#8217;s now add audio amplification and remote control. The different elements will be connected as depicted below:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/cabling.png" alt="Cabling overview" /></p>

<ul>
  <li>To amplifier: GND, VI2C, SDA and SCL are the required connections for I2C communication with the amplifier to digitally adjust gain/volume. In addition, the SHDN (Shutdown) pin of the amplifier is connected to one of the pi&#8217;s GPIO, so as to be able to disable the amplifier when not used.</li>
  <li>To TSOP IR receiver: GND, VCC, and SIGNAL (connected to the pi&#8217;s GPIO #18, as configured in LIRC). I also successfully tested this setup using TSOP4838, taking into account its specific pinout.<br /><br /></li>
</ul>

<p>Here is a work-in-progress view:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/audio_setup.png" alt="audio_setup" /></p>

<h3 id="communicating-with-the-amplifier-module">Communicating with the amplifier module</h3>

<p>The raspberry will control the amplifier module through its I2C interface, a.k.a. 2-Wire. Communication happens over two lines:</p>

<ul>
  <li>SDA: Serial DAta</li>
  <li>SCL: Serial CLock</li>
</ul>

<p>In addition to these two pins and the GND, the reference voltage for I2C communication shall also be provided to the amplifier: just connect one of the raspi 5V pins to the amp&#8217;s VI2C pin.</p>

<p>Scan the bus, the amp should be detected at address 0x4B:</p>

<pre><code>sudo i2cdetect -y 1

     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- 4b -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- --   
</code></pre>

<p><strong>Note</strong>: with some raspi distributions you may see a &#8220;UU&#8221; value at address 0x1b: this is due to the kernel driver for tas5713 amplifier that comes in the Wolfson audio add-on card for rasp. Not sure why this is not blacklisted by default since most people do not have this addon card on their pi, but anyway, I did not want to take any chance of an unused kernel driver using the I2C bus while I am using it to communicate with the external amplifier. So I blacklisted the TAS5713 driver:</p>

<pre><code>sudo nano /etc/modprobe.d/raspi-blacklist.conf
</code></pre>

<p>adding this line :</p>

<pre><code>blacklist snd_soc_tas5713
</code></pre>

<p>The protocol to communicate with the amplifier module is extremely simple : just write a volume value between 0x0 and 0x3F (63 is the max value, since volume is coded on 6 bits), at address 0x4B. For example to set volume to the medium value:</p>

<pre><code>sudo i2cset -y 1 0x4B 0x20
</code></pre>

<h4 id="configuring-ir-remotereceiver">Configuring IR remote/receiver</h4>

<p>First, let&#8217;s stop the LIRC daemon since we will be accessing the LIRC input device for these tests:</p>

<pre><code>sudo /etc/init.d/lirc stop
</code></pre>

<p>To check that cabling is correct and TSOP is working properly:</p>

<pre><code>mode2 -d /dev/lirc0
</code></pre>

<p>When pressing buttons on the remote, you should see messages (&#8220;pulse xxx space yyy&#8221;) being displayed.<br /><br />
Next, we need to generate the config file associated to our remote:</p>

<pre><code>irrecord -d /dev/lirc0 -f lircd.conf
</code></pre>

<p><strong>Note</strong>: the <code>-f</code> option is normally not necessary. It worked fine without this option with one kind of remote I had, but I had to add it for the specific model of remote I finally used, otherwise I was getting an error &#8220;Something went wrong&#8221; during the irrecord setup process. <br /><br /></p>

<p>This will guide you through a sequence of actions with the remote. First, a detection is performed by just pressing various buttons on the remote repeatedly. In the end, you will be requested to map the key codes (which names are available by executing:	<code>irrecord --list-namespace</code>), and to press the corresponding button on the remote.<br /><br /></p>

<p>In my case, I mapped the following names/buttons:</p>

<pre><code>KEY_POWER
KEY_MUTE
KEY_KPPLUS
KEY_KPMINUS
KEY_PLAY
KEY_NEXT
KEY_PREVIOUS
KEY_1
KEY_2
KEY_3
KEY_4
KEY_5
KEY_6
KEY_7
KEY_8
KEY_9
</code></pre>

<p>Edit the generated <code>lircd.conf</code> file and provide a name for your remote (e.g. &#8220;piremote&#8221;). Then copy the file to its official location:</p>

<pre><code>sudo cp lircd.conf /etc/lirc/lircd.conf
</code></pre>

<p>Relaunch the LIRC daemon</p>

<pre><code>sudo /etc/init.d/lirc restart
</code></pre>

<p>To test that key presses are properly taken into account, you can execute <code>irw</code> and push some buttons on the remote: the corresponding key codes shall be displayed.</p>

<h4 id="controlling-the-audio-playback">Controlling the audio playback</h4>

<p>The LMS has a command line interface that can be leveraged to remotely control audio playback: just telnet into the server pi on port 9090, and use the LMS CLI format. Here are a few one-liner examples:<br /><br /></p>

<p>Play:</p>

<pre><code>echo "[MAC address of the squeezelite player] play" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>Pause/play toggle:</p>

<pre><code>echo "[MAC address of the squeezelite player] pause" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>Stop:</p>

<pre><code>echo "[MAC address of the squeezelite player] stop" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>Adjust volume:</p>

<pre><code>echo "[MAC address of the squeezelite player] mixer volume -10" | telnet [IP address of the raspi running LMS] 9090
echo "[MAC address of the squeezelite player] mixer volume +10" | telnet [IP address of the raspi running LMS] 9090
echo "[MAC address of the squeezelite player] mixer volume 50" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>Mute/unmute toggle :</p>

<pre><code>echo "[MAC address of the squeezelite player] mixer muting" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>Next song in playlist:</p>

<pre><code>echo "[MAC address of the squeezelite player] playlist index +1" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>Previous song in playlist:</p>

<pre><code>echo "[MAC address of the squeezelite player] playlist index -1" | telnet [IP address of the raspi running LMS] 9090
</code></pre>

<p>For a basic use, just binding remote control commands from LIRC to some of these actions will work just fine, just configure the LIRC daemon to associate specific actions to each key code. This is achieved (for example) by creating a global <code>lircrc</code> file in <code>/etc/lirc</code>:</p>

<pre><code>sudo nano /etc/lirc/lircrc
</code></pre>

<p>Below is an example content I experimented with at some point:</p>

<pre><code>begin
    prog = irexec
    remote = piremote
    button = KEY_POWER
    config = echo "not implemented yet"
end

begin
    prog = irexec
    remote = piremote
    button = KEY_MUTE
    config = echo "80:1f:02:65:39:47 mixer muting" | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_KPPLUS
    config = echo "80:1f:02:65:39:47 mixer volume +5" | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_KPMINUS
    config = echo "80:1f:02:65:39:47 mixer volume -5" | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_PLAY
    config = echo "80:1f:02:65:39:47 pause" | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_NEXT
    config = echo "80:1f:02:65:39:47 playlist index +1" | telnet 192.168.0.45 9090
end

begin
    prog = irexec
    remote = piremote
    button = KEY_PREVIOUS
    config = echo "80:1f:02:65:39:47 playlist index -1" | telnet 192.168.0.45 9090
end
</code></pre>

<h4 id="installing-pylirc">Installing PyLIRC</h4>

<p>Even though the <code>lircrc</code> config allows to define actions to be executed for each button, I needed a bit more flexibility: for example to implement a stateful audio controller that keeps track of current volume, or that I could turn on / turn off using a single button. Luckily, there is a Python binding for LIRC available: PyLIRC2. Installation goes like this:<br /><br /></p>

<p>1) get PyLIRC2 from <code>https://pypi.python.org/pypi/pylirc2</code></p>

<pre><code>wget https://pypi.python.org/packages/source/p/pylirc2/pylirc2-0.1.tar.gz
</code></pre>

<p>2) install the necessary python headers</p>

<pre><code>sudo apt-get install python-python-dev
</code></pre>

<p>3) uncompress it:</p>

<pre><code>tar xvzf pylirc2-0.1.tar.gz 
</code></pre>

<p>4) launch install script:</p>

<pre><code>cd pylirc2-0.1/
sudo python setup.py install
</code></pre>

<p>5) create a python controller script and associated config file:</p>

<ul>
  <li>the config file reuses the <code>lircrc</code> format</li>
  <li>the controller script is homemade and very basic: it just polls pylirc for incoming commands received from the IR receiver (using the blocking mode to avoid spinning CPU for nothing), and launches a telnet command on the LMS accordingly.<br /><br /></li>
</ul>

<p>On the server side, 9 playlists named <code>playlist_xx.m3u</code> are stored in the media folder, and pressing buttons 1 to 9 on the remote trigs one of these playlists. I mapped a few albums to some of the 9 buttons, and web radios to the others. The playlist format (m3u) is very basic, it boils down to one entry per line with the path to a song. A convenient way to generate a playlist corresponding to a full album is:</p>

<pre><code>find /home/pi/music/SomeAlbumName/ -name *.mp3 | sort &gt; playlist.m3u
</code></pre>

<p>A few specific details were implemented in the controller:</p>

<ul>
  <li>on/off management: when turning the player on/off, an audio confirmation was added. Indeed, in my case the audio client pi is hidden in the ceiling, with no visible mean to check if the system is currently on or off. So I just play a small audio jingle when turning the player on, and a different jingle when turning it off. Also, upon OFF (respectively ON) command, the shutdown GPIO is set to low (respectively high) so that the audio amplifier goes to (respectively exits) shutdown/ultra low power mode.</li>
  <li>error management: since the pi hosting this code will not be easily accessible once installed, I added various checks &amp; try/repeat loops to handle error cases, so that the script is as robust as possible to error conditions.</li>
</ul>

<p>My config file is available <a href="https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/conf">here</a>, and <a href="https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/audioController.py">here&#8217;s</a> the controller code. The script uses an external configuration file to store the server IP address and its own MAC address, as well as the path to the file when outputs are logged.</p>

<h3 id="automate-launch-at-pi-startup">Automate launch at Pi startup</h3>

<p>Once everything worked as expected, I proceeded with automating the execution of the audio controller script at startup. I chose to turn it into a background service/daemon, using <a href="http://blog.scphillips.com/2013/07/getting-a-python-script-to-run-in-the-background-as-a-service-on-boot/">these</a> great instructions. My version is available <a href="https://github.com/jheyman/multiroomhomeaudio/blob/master/client_side/audiocontroller.sh">here</a>, I just added the <code>--chdir</code> option in the <code>start-stop-daemon</code> command to set the working directory of the service to be the one the script and its associated files are stored in, so that no absolute paths need to be specified inside the script. Just copy this script to <code>/etc/init.d</code>, make sure it has execution rights, then add activate this service:</p>

<pre><code>sudo cp audiocontroller.sh /etc/init.d/audiocontroller.sh
sudo chmod a+x /etc/init.d/audiocontroller.sh
sudo update-rc.d audiocontroller.sh defaults
</code></pre>

<p>Reboot the pi: traces of the successful execution of the audio controller script should be visible in <code>/tmp/audiocontroller.log</code> file.<br /><br /></p>

<p>NOTE: in my case, it&#8217;s a good thing I inserted a check &amp; retry loop on pinging the LMS server at the beginning of the script, since the wifi connection does not come up immediately at startup, and the script would otherwise exit in error.<br /><br /></p>

<p>Final touch: since at least one of the client pi is installed in my attic, I wanted to be able to power-cycle it in case of errors. To achieve this, I just plugged the pi power supply on a Z-Wave relay, that can be turned off/on remotely. See <a href="http://jheyman.github.io/blog/pages/ZwaveHomeAutomation">ZwaveHomeAutomation</a> project for details.</p>

<h3 id="physical-installation">Physical installation</h3>

<p>With everything up and running, I proceeded with installing the system in one of the rooms. I bought a couple of small ceiling-mountable speakers, here is what one of them looks like after being installed:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/speaker_installed.png" alt="speaker in ceiling" /></p>

<p>Regarding the IR receiver, there was no convenient way to hide it somewhere in the room, so I chose another appraoch: buying a ceiling-mountable presence sensor, getting rid of the electronics inside, and installing my IR receiver diode instead. Basically I just reused the casing. Here it is:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/IR_shell.png" alt="IR_shell" /></p>

<p>And here is the IR receiver soldered onto the front of the (now totally useless) PCB. The three leads are soldered onto an existing output connector of the module:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/IR_receiver_in_shell.png" alt="IR_receiver_in_shell" /></p>

<p>Finally, here it is installed on the ceiling:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/IR_shell_installed.png" alt="IR_shell_installed" /></p>

<h3 id="installing-in-additional-rooms">Installing in additional rooms</h3>

<p>The exact same steps as above can be used to install additional players in other rooms, the only required modification is to change the MAC address in the audio controller config file.
Wash, rinse and repeat.</p>

<h3 id="additional-tuning-for-integration-with-gcalnotifier">Additional tuning for integration with gcalnotifier</h3>

<p>Based on this audio setup, I also came up with a service playing audio reminders at predefined times (from google calendar entries + voice synthesis), see <a href="http://jheyman.github.io/blog/pages/GoogleCalendarAudioNotifier">this project</a>. One problem to address was to pause music playback before the event announcement, and resume it afterwards. A few modifications were required to achieve this:</p>

<p>I added these two entries in <code>/etc/lirc/lircd.conf</code>, in the codes section:</p>

<pre><code>KEY_START_ANNOUNCE              0x1234
KEY_END_ANNOUNCE                0x5678
</code></pre>

<p>(note: this format only works if the lird.conf file does not use raw code format, i.e. if <code>-f</code> option was not used. I have not found an easy way to create dummy raw_codes AND be able to simulate them, but there&#8217;s probably a way to do it&#8230;) <br /><br />
They are dummy entries not corresponding to any physical button on the remote, but will be used to simulate IR events from the command line, allowing gcalnotifier daemon to send requests to the audiocontroller as if they came from the remote control like the others. Consequently, I updated the pylirc <code>conf</code> file with these two entries:</p>

<pre><code>begin
    prog = pylirc
    remote = piremote
    button = KEY_START_ANNOUNCE
    config = start_announce
end


begin
    prog = pylirc
    remote = piremote
    button = KEY_END_ANNOUNCE
    config = end_announce
end
</code></pre>

<p>To simulate the reception of the two corresponding IR commands, use:</p>

<pre><code>irsend simulate "0000000000004660 0 KEY_START_ANNOUNCE piremote"
irsend simulate "0000000000022136 0 KEY_END_ANNOUNCE piremote"
</code></pre>

<p>(the key code must have exactly 16 digits and be written in decimal format)<br /><br /></p>

<p>Finally, I modified the audio controller script to react to these two events:
- when receiving &#8220;start_announce&#8221;, mute the music (if required) and activate amplifier (if required e.g. if audio controller was &#8220;off&#8221;) 
- when receiving &#8220;end_announce&#8221;, unmute the music (if required), and desactivate amplifier again (unless audio controller is still &#8220;on&#8221;)</p>

<h3 id="squeezelite-robustness-workaround">Squeezelite robustness workaround</h3>
<p>I encountered an issue where the audio controller would stop working correctly after a few hours. The problem turned out to be in squeezelite, since the rest of the controller was still responding correctly, and just restarting the squeezelite daemon was fixing the issue. It might be related to <a href="http://code.google.com/p/squeezelite/issues/detail?id=17">this</a>, especially since I only encountered this issue in the setup where audio output is shared (my other setups based on the same squeezelite with exclusive access to the sound output do not show this problem). But anyway since there was no clue in squeezelite logs as to what the problem might be, I gave up and first implemented a simple workaround: restarting the local squeezelite client every time the audio controller is turned on. <br /><br /></p>

<p>However, additional investigation showed that this robustness issue was apparently due to the use of the shared sound output through alsa&#8217;s dmix. If I turned off this sharing configuration, with the DAC being exclusively allocated to squeezelite, the setup would run A-OK for days. Since I really wanted to keep the ability to host both this music player and the calendar audio notifier on the same raspberry, I finally chose a brutal workaround: using two DACs and mixing their outputs in HW.</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/doubleDAC_mixing.png" alt="double DAC mixing" /></p>

<p>Such a simple passive HW mixing obviously has one downside: volume loss at the output. However, since in this particular setup the output of the DACs goes to an amplifier, in the end their is more than enough gain in the amplifier to compensate for that loss, so all is good.</p>

<p><strong><em>Note</em></strong>: you will probably want to set the output volume of both DACs to the same volume, for proper consistent sound mixing. This is done through <code>alsamixer</code> as usual, just press <code>F6</code> to select each DAC in turn.<br /><br /></p>

<p>Here is my finished setup:</p>

<p><img src="http://jheyman.github.io/blog/assets/images/MultiRoomHomeAudio/example_setup.png" alt="Example setup" /></p>

<p>(the nRF24 radio module is present because I am running my <a href="http://jheyman.github.io/blog/pages/WirelessWaterMeter">wireless water meter</a> on the same raspberry pi)</p>

<h3 id="ir-receiver-sensibility-to-z-wave-light-dimmer-control">IR receiver sensibility to Z-Wave light dimmer control</h3>

<p>I stumbled upon an intermittent robustness issue, where at random times the IR remote controlling the playback would work very erratically. Connecting to the client raspberry pi and launching <code>mode2 -d /dev/lirc0</code>, I noticed that IR pulses where being detected continuously, even when not using the remote. Here is a short snippet of the observed signal:</p>

<pre><code>space 19991
space 19998
space 19993
space 19992
space 19994
space 19993
space 20005
pulse 0
space 19987
space 20015
pulse 0
space 19981
space 40022
pulse 0
space 19949
space 19996
space 19991
space 19995
space 19989
space 20001
pulse 0
space 19988
space 19996
space 19995
space 19993
space 19995
space 19992
space 19995
</code></pre>

<p>So, something was causing background noise on the IR signal. I quickly found out that turning off the room lights made the problem disappear, and thought of ambient light interference on the IR sensor. However, this was quite unlikely since the IR receiver is designed with built-in ambient light filtering, and the IR signal modulation at 38 kHZ is also supposed to prevent such issues.</p>

<p><br />In fact, it so happens that in the room where this setup is installed, the (LED) lights are controlled by a z-wave dimmer (see my <a href="http://jheyman.github.io/blog/pages/ZwaveHomeAutomation">home automation project</a> for details), and that the dimmer module works by modulating the output power at a varying rate. With dimming level anywhere between 50% and 100%, the IR receiver picked up IR noise from this modulation, while setting the dimmer level below 50% made the interference disappear. Long story short, I finally just modified the configuration of the z-wave dimmer to set the max dimming level to below 50%, to avoid this weird interference phenomenon (note: this is done by adjusting parameter #12 <em>Maximum dimmer level control</em> in the configuration menu of the z-wave device). This also meant a lower max luminosity in the room, but in this specific case it was not a problem.</p>

<h3 id="misc">Misc</h3>
<ul>
  <li>I was a bit concerned regarding the amount of CPU power required to run the audio server and clients. As it turns out, streaming audio LMS takes less than 3% CPU time on the server, while on the client side squeezelite takes about 10% CPU time. So no big deal in either case, both the server and the client pi&#8217;s can handle a lot of additional functions.</li>
  <li>I encountered cases where mp3 music playback was too fast. It turns out this was due to a mismatch between the mp3 sample rate (usually 44100kHz) and the supported rates on the selected audio output. For example, with my USB DAC, when selecting it as <code>front:CARD=Device,DEV=0</code> in squeezelite startup script, it seems to only support 48000 kHz, so it was playing 44100 kHz data at 48000kHz, resulting in accelerated playback:</li>
</ul>

<pre><code>
	pi@raspberrypi $ squeezelite-armv6hf <b><font color="red">-o front:CARD=Device,DEV=0 </font></b>  -d output=debug
	[18:06:25.825811] output_init_alsa:643 init output
	[18:06:25.828172] output_init_alsa:666 requested alsa_buffer: 40 alsa_period: 4 format: any mmap: 1
	[18:06:25.829251] output_init_common:342 outputbuf size: 3528000
	[18:06:25.881301] output_init_common:402 supported rates: <b><font color="red">48000</font></b> 
	[18:06:25.899311] output_init_alsa:678 memory locked
	[18:06:25.901990] output_thread:467 open output device: front:CARD=Device,DEV=0
	[18:06:25.902316] alsa_open:185 opening device at: 48000
	[18:06:25.907014] alsa_open:236 opened device front:CARD=Device,DEV=0 using format: S16_LE sample rate: 48000 mmap: 1
	[18:06:25.907566] alsa_open:315 buffer: 40 period: 4 -&gt; buffer size: 1920 period size: 480
	[18:06:25.909618] output_init_alsa:701 set output sched fifo rt: 45
	[18:06:27.552985] _output_frames:59 start buffer frames: 7535
	[18:06:27.553269] _output_frames:144 track start sample rate: 44100 replay_gain: 0
	[18:06:27.563528] output_thread:467 open output device: front:CARD=Device,DEV=0
	[18:06:27.564720] alsa_open:185 opening device at: 44100
	[18:06:27.569978] alsa_open:236 opened device front:CARD=Device,DEV=0 using format: S16_LE sample rate: 44100 mmap: 1
	[18:06:27.570361] alsa_open:315 buffer: 40 period: 4 -&gt; buffer size: 1920 period size: 480
	[18:06:34.349284] output_close_alsa:706 close output
</code></pre>

<p>When selecting the same output device but with squeezelite <code>plughw</code> prefix (i.e. direct access to DAC hw), many supported rates showed up including 44100, and playback was fine:</p>

<pre><code>
	pi@raspberrypi $ squeezelite-armv6hf <b><font color="red">-o plughw:CARD=Device,DEV=0</font></b>   -d output=debug
	[18:07:45.154675] output_init_alsa:643 init output
	[18:07:45.157013] output_init_alsa:666 requested alsa_buffer: 40 alsa_period: 4 format: any mmap: 1
	[18:07:45.158419] output_init_common:342 outputbuf size: 3528000
	[18:07:45.192283] output_init_common:402 supported rates: <b><font color="red">384000 352800 192000 176400 96000 88200 48000 44100 32000 24000 22500 16000 12000 11025 8000</font></b>  
	[18:07:45.210337] output_init_alsa:678 memory locked
	[18:07:45.212892] output_thread:467 open output device: plughw:CARD=Device,DEV=0
	[18:07:45.213212] alsa_open:185 opening device at: 44100
	[18:07:45.218350] alsa_open:236 opened device plughw:CARD=Device,DEV=0 using format: S32_LE sample rate: 44100 mmap: 1
	[18:07:45.220322] alsa_open:315 buffer: 40 period: 4 -&gt; buffer size: 1764 period size: 441
	[18:07:45.226598] output_init_alsa:701 set output sched fifo rt: 45
	[18:07:47.165681] _output_frames:59 start buffer frames: 4079
	[18:07:47.166027] _output_frames:144 track start sample rate: 44100 replay_gain: 0
	[18:07:52.750732] output_close_alsa:706 close output
</code></pre>

<h3 id="todo">Todo</h3>

<p>I&#8217;d like to leverage the newly added audio capabilty in each equipped room for:</p>

<ul>
  <li>adding a microphone to the setup, in order to use the client pi as intercom endpoints between rooms.</li>
</ul>

<h3 id="lessons-learned">Lessons learned</h3>

<ul>
  <li>for once, everything initially went very smoothly: IR remote control with LIRC is a breeze to setup and use, the pi is easy as ever to setup, and controlling the audio amplifier through I2C and GPIOs worked the first time.</li>
  <li>
    <p>there were however a few hiccups after a while:</p>

    <ol>
      <li>The squeezelite robustness issue &amp; Z-wave module interference mentionned above.</li>
      <li>I did struggle to get a (very) stable wifi configuration. Refer to <a href="http://jheyman.github.io/blog/pages/RaspberryPiTipsAndTricks">this page</a> for various wifi-related tips on the raspi.</li>
      <li>On one of the raspi, I got random short blank gaps during music playback, with no obvious error in squeezelite logs. I finally fixed those by using the <code>plughw</code> format in the selection of the audio output in suqeezelite startup script.</li>
    </ol>
  </li>
  <li>I realized that sometimes, just pushing a button on a (physical) remote is way more convenient than grabbing you phone, unlocking it, navigating to a specific app, opening it, and finally clicking somewhere.</li>
  <li>2x20W amplification is plenty enough for small rooms, I never had to turn the volume all the way up, by far. A different approach with be required for the living room audio though.</li>
</ul>


				</div><!-- entry-content -->

				<br>
				<hr>
				<div class="misc-content">			
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'jheymantechblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




				</div><!-- misc-content -->				
			</div><!-- bd -->

			<footer class="unit-foot">
				<div class="unit-inner unit-foot-inner">
					<p class="gotop">
						<a href="#page">Back to Top</a>
					</p>
				</div>
			</footer>

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>


				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
	</div><!-- body -->
	<footer class="the-footer">
		<div class="unit-foot">
			<div class="unit-inner unit-foot-inner">
				<div class="misc vcard">
					<h4>about</h4>
					<ul>
						<li class="contact"><address><span class="author fn n">Julien Heyman</span> - <span class="fn email">bidsomail at gmail.com</span></address></li>
						<li>Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>, theme based on the_minimum from <a href="http://jekyllbootstrap.com/">Jekyll-bootstrap</a></li>
					</ul>
				</div><!-- misc -->
			</div><!-- unit-foot-inner -->
		</div><!-- unit-foot -->
	</footer>
</div><!-- page -->
<script>
	(function(d, s) {
		var js, fjs = d.getElementsByTagName(s)[0], load = function(url, id) {
		if (d.getElementById(id)) {return;}
		js = d.createElement(s); js.src = url; js.id = id;
		fjs.parentNode.insertBefore(js, fjs);
		};
	load('//platform.twitter.com/widgets.js', 'tweetjs');
	// load('https://apis.google.com/js/plusone.js', 'gplus1js'); // Checkout http://j.mp/ApDgMr for usage html for this is <div class="g-plusone" data-size="medium"></div>
	// load('//connect.facebook.net/en_US/all.js#xfbml=1', 'fbjssdk'); // Checkout http://j.mp/wZw2xR for using open graph protorol html for this is <div class="fb-like" data-href="/pages/MultiRoomHomeAudio/index.html" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="verdana"></div>
	}(document, 'script'));
</script>
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>

  


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-43264312-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



</body>
</html>

